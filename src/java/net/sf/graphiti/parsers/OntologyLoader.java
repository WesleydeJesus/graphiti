/*
 * Copyright (c) 2008, IETR/INSA of Rennes
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the IETR/INSA of Rennes nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
package net.sf.graphiti.parsers;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.List;
import java.util.ResourceBundle;
import java.util.Set;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import net.sf.graphiti.model.DocumentConfiguration;
import net.sf.graphiti.model.Vertex;
import net.sf.graphiti.ontology.OntologyFactory;
import net.sf.graphiti.ontology.attributes.ColorAttribute;
import net.sf.graphiti.ontology.attributes.FigureAttribute;
import net.sf.graphiti.ontology.attributes.ShapeAttribute;
import net.sf.graphiti.ontology.enums.Shapes;
import net.sf.graphiti.ontology.parameters.EdgeParameter;
import net.sf.graphiti.ontology.parameters.GraphParameter;
import net.sf.graphiti.ontology.parameters.Parameter;
import net.sf.graphiti.ontology.parameters.VertexParameter;
import net.sf.graphiti.ontology.types.EdgeType;
import net.sf.graphiti.ontology.types.VertexType;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.FileLocator;
import org.eclipse.core.runtime.IContributor;
import org.eclipse.core.runtime.IExtensionRegistry;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Platform;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.spi.RegistryContributor;
import org.eclipse.swt.graphics.Color;
import org.osgi.framework.Bundle;
import org.osgi.framework.BundleContext;
import org.w3c.dom.Document;
import org.w3c.dom.Element;

/**
 * This class loads the ontologies present in the src/owl folder.
 * 
 * @author Matthieu Wipliez
 * 
 */
public class OntologyLoader {

	private List<DocumentConfiguration> configurations;

	private BundleContext context;

	/**
	 * Creates a new ontology loader in the given bundle context.
	 * 
	 * @param context
	 *            The Activator#start bundle context.
	 * @throws CoreException
	 *             Whenever something bad happens.
	 */
	public OntologyLoader(BundleContext context) throws CoreException {
		this.context = context;
		configurations = loadOntologies();
		addContribution();
	}

	/**
	 * Adds a contribution to the extension registry using a plugin.xml-like
	 * stream generated by getExtensionInputStream().
	 */
	@SuppressWarnings("restriction")
	private void addContribution() {
		IExtensionRegistry registry = Platform.getExtensionRegistry();

		InputStream is = getExtensionInputStream();
		long id = context.getBundle().getBundleId();
		IContributor contributor = new RegistryContributor(Long.toString(id),
				"net.sf.graphiti", null, null);
		boolean persist = false;
		String name = "Graphiti";
		ResourceBundle translationBundle = null;
		Object token = ((org.eclipse.core.internal.registry.ExtensionRegistry) registry)
				.getTemporaryUserToken();

		registry.addContribution(is, contributor, persist, name,
				translationBundle, token);
	}

	private void addExtensions(Document document, Element root) {
		Element extension = document.createElement("extension");
		extension.setAttribute("point", "org.eclipse.ui.newWizards");
		root.appendChild(extension);

		Element wizard = document.createElement("wizard");
		wizard.setAttribute("category", "net.sf.graphiti.ui.wizards.graph");
		wizard.setAttribute("class",
				"net.sf.graphiti.ui.wizards.NewGraphWizard");
		wizard.setAttribute("icon", "icons/sample.gif");
		wizard.setAttribute("id", "net.sf.graphiti.ui.wizards.GraphNewWizard");
		wizard.setAttribute("name", "SDF graph");
		wizard.setAttribute("project", "true");
		extension.appendChild(wizard);

		wizard = document.createElement("wizard");
		wizard.setAttribute("category", "net.sf.graphiti.ui.wizards.graph");
		wizard.setAttribute("class",
				"net.sf.graphiti.ui.wizards.NewGraphWizard");
		wizard.setAttribute("icon", "icons/sample.gif");
		wizard.setAttribute("id", "net.sf.graphiti.ui.wizards.GraphNewWizard");
		wizard.setAttribute("name", "Dataflow network");
		wizard.setAttribute("project", "true");
		extension.appendChild(wizard);
	}

	/**
	 * Returns a reference to the configuration list. Please note that this
	 * method merely returns the configuration list created by OntologyLoader
	 * constructor.
	 * 
	 * @return A reference to the configuration list.
	 */
	public List<DocumentConfiguration> getConfigurations() {
		return configurations;
	}

	/**
	 * Creates a DOM document, fills it with extension points, and returns it as
	 * a byte array input stream.
	 * 
	 * @return A {@link ByteArrayInputStream}.
	 */
	private InputStream getExtensionInputStream() {
		// Gets the document builder factory
		DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
		try {
			DocumentBuilder builder = factory.newDocumentBuilder();

			// Root element
			Document document = builder.newDocument();
			Element root = document.createElement("plugin");
			document.appendChild(root);

			// Adds extensions
			addExtensions(document, root);

			// Set up the output transformer
			TransformerFactory transfac = TransformerFactory.newInstance();
			Transformer trans = transfac.newTransformer();
			trans.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "no");
			trans.setOutputProperty(OutputKeys.INDENT, "yes");

			// Print the DOM node
			ByteArrayOutputStream bos = new ByteArrayOutputStream();
			StreamResult result = new StreamResult(bos);
			DOMSource source = new DOMSource(document);
			trans.transform(source, result);

			return new ByteArrayInputStream(bos.toByteArray());
		} catch (ParserConfigurationException e) {
			e.printStackTrace();
		} catch (TransformerException e) {
			e.printStackTrace();
		}

		return null;
	}

	/**
	 * Enumerates *.owl files in the bundle, and calls loadOntology on each of
	 * them.
	 * 
	 * @return A list of document configurations, one per ontology.
	 * @throws CoreException
	 */
	private List<DocumentConfiguration> loadOntologies() throws CoreException {
		List<DocumentConfiguration> configurations = new ArrayList<DocumentConfiguration>();
		Bundle bundle = context.getBundle();
		Enumeration<?> e = bundle.findEntries("bin", "*.owl", false);
		while (e.hasMoreElements()) {
			URL url = (URL) e.nextElement();
			try {
				url = FileLocator.toFileURL(url);
				String file = url.getPath();
				DocumentConfiguration config = loadOntology(file);
				configurations.add(config);
			} catch (IOException e1) {
				String pluginId = Long.toString(bundle.getBundleId());
				String message = "Ontology not found";
				IStatus status = new Status(Status.ERROR, pluginId, message, e1);
				throw new CoreException(status);
			}
		}

		return configurations;
	}

	/**
	 * Loads the ontology in the given file, creates a document configuration,
	 * fills it in with the ontology, and returns it.
	 * 
	 * @param file
	 *            The file that contains the ontology.
	 * @return The document configuration created and filled in.
	 * @throws CoreException
	 */
	private DocumentConfiguration loadOntology(String file)
			throws CoreException {
		try {
			System.out.println("Loading ontology: " + file);
			DocumentConfiguration config = new DocumentConfiguration(file);

			OntologyFactory factory = new OntologyFactory(file);
			Set<VertexType> vertexTypes = factory.getVertexTypes();
			for (VertexType type : vertexTypes) {
				String vertexType = type.hasStringRepresentation();
				Set<FigureAttribute> attributes = type.hasFigureAttributes();
				for (FigureAttribute attribute : attributes) {
					if (attribute.hasOntClass(OntologyFactory
							.getClassColorAttribute())) {
						Color color = ((ColorAttribute) attribute).hasColor()
								.getColor();
						config.setVertexAttribute(vertexType,
								Vertex.ATTRIBUTE_COLOR, color);
					} else if (attribute.hasOntClass(OntologyFactory
							.getClassShapeAttribute())) {
						Shapes shape = ((ShapeAttribute) attribute).hasShape();
						config.setVertexAttribute(vertexType,
								Vertex.ATTRIBUTE_SHAPE, shape);
					}
				}

				Set<Parameter> parameters = type.hasParameters();
				for (Parameter parameter : parameters) {
					if (parameter.hasOntClass(OntologyFactory
							.getClassVertexParameter())) {
						net.sf.graphiti.model.Parameter param = new net.sf.graphiti.model.Parameter(
								(VertexParameter) parameter);
						config.addVertexParameter(vertexType, param);
					} else if (parameter.hasOntClass(OntologyFactory
							.getClassEdgeParameter())) {
						net.sf.graphiti.model.Parameter param = new net.sf.graphiti.model.Parameter(
								(EdgeParameter) parameter);
						config.addEdgeParameter(vertexType, param);
					} else if (parameter.hasOntClass(OntologyFactory
							.getClassGraphParameter())) {
						net.sf.graphiti.model.Parameter param = new net.sf.graphiti.model.Parameter(
								(GraphParameter) parameter);
						config.addGraphParameter(vertexType, param);
					}
				}
			}

			Set<EdgeType> edgeTypes = factory.getEdgeTypes();
			for (EdgeType type : edgeTypes) {
				String edgeType = type.hasStringRepresentation();
				Set<Parameter> parameters = type.hasParameters();
				for (Parameter parameter : parameters) {
					if (parameter.hasOntClass(OntologyFactory
							.getClassEdgeParameter())) {
						net.sf.graphiti.model.Parameter param = new net.sf.graphiti.model.Parameter(
								(EdgeParameter) parameter);
						config.addEdgeParameter(edgeType, param);
					}
				}
			}

			return config;
		} catch (Exception e) {
			Bundle bundle = context.getBundle();
			String pluginId = Long.toString(bundle.getBundleId());
			String message = "Exception occurred";
			IStatus status = new Status(Status.ERROR, pluginId, message, e);
			throw new CoreException(status);
		}
	}

}
